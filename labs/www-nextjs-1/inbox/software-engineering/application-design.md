## InBox

-   Декларативно-генеративный подход, лпирающийся на спецификации (тесты).
-   Рассматривать приложеник как виртуального человека-ассистента.
-   Возможно, на этапе композиции приложения вообще не должно быть чего-либо связанного непосредственно с исполнением приложения. Скажем, конфигурирования. Всё внутри на flow, на service-container.

## Flow

-   Есть предположение, что flow является ключевым компонентом системы. Если рассмотреть сервис-контейнер, то это factory-компонент потока, который запрашивает сервис и получает реализацию. Тесты - расширенный поток, добавляющий эмиттер данных и коллектор результатов с их проверкой (возможность flow manager добавлять узлы в самые разные места позволит с легкостью реализовать на одной основе unit/api/e2e-тесты). Конфигурация - по сути обработчик событий (ISomeSettings) из абстрактного источника (от watcher конфигурационного файла до service discovery), который по данным service container вычислит заинтересованные зависимости и их оповестит или пересоздаст. Возможно, такой обобщенный паттерн может получить название "Application".
-   В качесте примера flow можно привести эволюцию от for до do-нотации (C# LINQ, ES map/filter/reduce/etc). Схожая заметка была в [Управляющие конструкции](README.md).
-   For<TRequest>().When(...).Expect(...);
    -   По умолчанию все процессы поразумеваются как параллельные.
    -   Чем-то похоже на BDD. Не исключено, что это оно и есть.
    -   Также похоже и на регистрацию сервисов.
-   Для перехода из одной категории в другую можно описывать самые разные стратегии (также в сервис-контейнере). Скажем, взять Valid<> -> Preprocessed<>, для которой определить асинхронный запуск всех сервисов, Task.WaitAll и собственно трансформацию Valid<> -> Preprocessed<>.

### IGene (ex. ICommand, ICommandHandler, etc)

-   IGene<TRequest<TResponse>>
-   IGene<TRequest, TResponse>
-   IGene<TRquest> -> Result.Subscribe<TResponse>

## Service container (IoC, DI)

-   Как быть в языках, которые не поддерживают рефлексию?
-   Возможность работы с контекстами (как дополнительные слои над базовыми сервисами).
    -   Скажем, зарегистрировать HttpContext/HttpRequest/HttpResponse, но не только. Любые декодированные в HTTP-pipeline данные могут регистрироваться с использованием SomeAppSpecificContext, а не размещаться в привычном строковом или объектном (boxing) словаре контекста.
    -   Реализация механимзмов форматирования и в целом реакции на ошибки в зависимости от контекстов.
    -   Или, как я писал в заметках ранее, namespaces для контейнера. Где namespaces - расширение примитивных keyed-service.
    -   Контексты, service scope и монады. Что в этом общего?

## Configuration

-   Конфигурация должна строиться по уведомительной системе без перезапуска приложения. Скажем отдельной взятый модуль (команда) указал на необходимость наличия заданных сеттингов (ISP) и их получил. Чуть сложнее может быть с синглтонами, возможно они должны пересоздаваться или обновляться, в зависимости от того используется ли constructor injection или другие подходы.
-   Конфигурация - это просто элемент flow. Ничем не отличается от многих других запросов. Например, конфигурацию можно брать из Service Discovery и тогда ничем не будет отличаться от любого другого сервиса.
-   Большая часть конфигурации должна осуществляться уже внутри приложения. Где я могу инжектить те или иные сервисы и настройки. А не в билдерах и т.п.

## Журналирование

-   Должно быть тесно интегрировано во flow
-   Вместо жёстко прощитых статусов, вроде LogLevel, могут быть категории Debug<Message>, Information<Message>.
-   Рассматривать исключительно как журналирование объекта, а не текста или текста с форматирование объектами.

## Тяжёлая судьба "Sign In request"

-   HTTP pipeline (Http<SignInRequest>)
    -   Журналирование. Просто проходит через фильтр. Пишет в некий IEventLog.
        -   Http<SignInRequest> -> Http<SignInRequest>?
        -   Может быть несколько команд для журналирования в разные провайдеры, выполнять параллельно.
        -   Может быть полностью асинхронным.
    -   Аутентификация. Проверяет на IP, JWT. Расширяет/создаёт context. Потенциально генерирует ошибки 401/403. Authenticated<SignInRequest>.
        -   Может понадобиться доступ к хранилищу.
        -   Может быть несколько команд.
    -   Интеллектуальный load balancer.
-   JSON декодирование. Потенциально генерирует ошибку 400. Может понадобиться доступ к настройкам (де)сериализации.
    -   Json<SignInRequest> -> NotValidated<SignInRequest>
-   Валидация. Потенциально генерирует ошибку 422.
    -   Json<SignInRequest> -> Valid<SignInRequest>
    -   Json<SignInRequest> -> Invalid<SignInRequest>
    -   Может быть цепочка валидаций для различных интерфейсов. В том числе параллельных.
-   Может быть какой-то дополнительный препроцессинг запроса (Preprocessed<SignInRequest>).
    -   Проставить дату запроса, чтобы проконтролировать хаммеринг. Pass-through.
    -   Подсолить Password. GDPR hashing. Pass-through.
    -   Теоретически все процессы, которые могут быть распараллелены и мы ожидаем Task.WaitAll.
-   Alerting. Генерация дополнительной асинхронной ветви обработки с отправкой уведомлений.
    -   В процессинге запросов выглядит не очень, поскольку в нём ожидается выполнение всех ветвей, а alerting может быть полностью автономным. Плюс, ему может понадобиться уже сформированный SignInRequest.
-   Отправка запроса в базу
    -   А если REST? И куда девать остальное "мясо" бизнес-команды?
    -   Автоматический роутинг в базу (Preprocessed<> -> DbRequest<>) для определённых категорий запросов?
    -   Есть такой пользователь
    -   Ошибка базы (SomeDbException)
    -   Нет такого пользователя (UserNotFoundException)
    -   Хаммеринг (следующие попытки будут доступны через...) (UserHammeringException)
-   Обработка ошибок (Exception -> FormattedException<TException>)
    -   Журналирование
    -   Уведомления
    -   Редирект на сконфигурированную страницу для ошибки
    -   Форматирование и перевод ошибок
