import React from "react";
import { Layout } from "../../../templates/layout";

//TODO:
export const Prerequisites = () => (
	<>
		<a>Важность реюзинга</a>
		<a>Функция</a>
	</>
);

export const Mesh = () => (
	<Layout>
		<header>
			<h1>Функциональное программирование</h1>
		</header>

		<section>
			<h2>"Специфичный" подход</h2>

			<p>
				Давайте представим, что перед нами встала задача написать модуль, осуществляющий
				некоторое сложное вычисление. Поскольку само вычисление в данном контексте не важно,
				мы упростим его до деления двух чисел и опишем простой спецификацией:
			</p>

			<table className="simple">
				<thead>
					<tr>
						<th>Значение</th>
						<th>Тип</th>
						<th>Описание</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Аргумент "x"</td>
						<td>Число</td>
						<td>Делимое</td>
					</tr>
					<tr>
						<td>Аргумент "y"</td>
						<td>Число</td>
						<td>Делитель</td>
					</tr>
					<tr>
						<td>Результат</td>
						<td>Число</td>
						<td>Частное</td>
					</tr>
				</tbody>
			</table>

			<p>
				Программа была успешно внедрена и долгое время всё было хорошо, пока не стали
				возникать ошибки. Проблему удалось быстро диагностировать и причиной оказалось
				деление на ноль. Настало время внести эту коррективу с спецификацию:
			</p>

			<table className="simple">
				<thead>
					<tr>
						<th>Значение</th>
						<th>Тип</th>
						<th>Описание</th>
					</tr>
				</thead>
				<tbody>
					<tr>
						<td>Аргумент "x"</td>
						<td>Число</td>
						<td>Делимое</td>
					</tr>
					<tr>
						<td>Аргумент "y"</td>
						<td>Число</td>
						<td>Делитель</td>
					</tr>
					<tr>
						<td>Результат</td>
						<td className="highlight">Число или ошибка деления на ноль</td>
						<td>Частное</td>
					</tr>
				</tbody>
			</table>

			<p>
				Теперь мы знаем, что помимо числового решения при некоторых обстоятельствах мы можем
				получить побочный эффект.
			</p>

			<p>
				Функциональный программирование в рамках "специфичного" подхода &mdash; это когда
				сигнатура функции выступает в роли спецификации. В нашем примере:
			</p>

			<code>{`
// Плохая спецификация
function Divide(x: int, y:int): int;

// Хорошая спецификация
function Divide(x: int, y: int): (int | DivideByZeroError);
			`}</code>

			<p>
				С учётом классической модели, что Output = Program(Input), такой подход может
				специфицировать практически всё приложение целиком.
			</p>

			<p>
				Теперь представим себя разработчиками, который использовали эту функцию деления в
				длинной цепочке вычислений:
			</p>

			<code>{`
a2 = div(a0, a1)
a3 = sqrt(a2)
a4 = 2*pi*a3
a5 = cos(a4)
			`}</code>

			<p>
				Как только мы внесли изменение и добавили возможность возврата ошибки, компилятор
				отказывает собирать наш код. С точки зрения надёжности это хорошо, но неработающая
				программа - плохо.
			</p>

			<p>
				Очевидно, что заставлять разработчиков всех остальных функций вносить изменения,
				обеспечивающие поддержку информации об ошибке нереально. Поэтому в индустрии было
				придумано самое простое решение - выбрасывать исключение. Это по сути паника
				локального масштаба. Мы останавливаем вычисление и надеемся, что кто-то "наверху"
				знает, что делать с этой ситуацией. Решение, мягко говоря, далекое от гибкости и
				универсальности.
			</p>

			<p>
				Чтобы получить больше контроля, представим себе некоторый вычислитель, который знает
				о возможности существовании ошибки в результате и реализует простую стратегию. Мы
				ему последовательно передаем вычисления, которые хотим осуществить. Если он видит
				нормальный результат, то осуществляет вычисление, в противном случае также возвращет
				ошибку. То есть:
			</p>

			<code>{`
value = div(a0, a1)
value = calc(value, x => sqrt(x))
value = calc(value, x => 2*pi*x)
value = calc(value, x => cos(x))
			`}</code>

			<p>
				Подобные вычислители получили в функциональном программировании название "монада".
				Первая строка реализует то, что принято называть pure-функцией монады,а остальные -
				bind.
			</p>
		</section>

		<section>
			<h2>"Грязные" эффекты</h2>

			<p>
				Часто можно услышать, что эффекты - это ввод/вывод, исключения и другие подобные
				аспекты. Но если представить себе программу, основная задача которой будет вывод на
				экран байт за байтом полученные данные из сетевого сокета, то несмотря на обилие
				"грязных" критериев, к ней сложно будет придраться.
			</p>

			<p>
				Проблемы возникают, когда что-то начинает происходить скрыто. Например, мы
				занимаемся разработкой пользовательского интерфейса для программы деления описанной
				выше. И для нас начинает представлять проблему, если побочный эффект от деления на
				ноль не специфицирован.
			</p>

			<p>
				TODO: Исключения могут быть, но это вопрос рантайма, который их будет обрабатывать?
				Так я могу более логично перейти к аспектному подходу.
			</p>
		</section>

		<section>
			<h2>Чистые функции и эффекты</h2>

			<p>
				TODO:Обычно определяют функциональные языки через чистоту функций. Во-первых, надо
				будет сделать сноску, что функциональный язык не тот, где всё чисто, а тот который
				может умело разделить основные задачи и эффекты.
			</p>

			<p>
				TODO:Функция деления. Выглядит достаточно чистой, но что если будет деление на ноль.
				Может объединить функциональный подход со спецификациями. Смысл в том, что определив
				функцию деления как просто Int &rarr; Int мы специфицируем её не до конца. Даже
				командный процессор может не иметь доступа к консоли (пример с хостингом Powershell
				и не путать с консольным приложением).
			</p>

			<p>
				TODO:Чистые данные - это данные, которые я хочу получить. Грязные данные содержат
				дополнительную информацию.
			</p>
		</section>

		<section>
			<h2>Монады</h2>

			<p>
				Представим себе существование некоторого объекта, скажем число 5. К нему может быть
				применена некоторая функция. Например f(x) = x*2. Дальше, большинство евангелистов
				предлагает преставить себе либо некоторый ящик, либо контекст. И речь идёт о том,
				что применение функции f теперь уже будет зависеть от контекста (возможно не стоит
				думать о применении функции к ящику и вообще о ящике).
			</p>

			<p>
				Например, монада Maybe. Когда этот ящик открывается, там может оказаться либо 5,
				либо ничего. type Maybe a = Just a | Nothing. И вот здесь возникает вопрос, как
				применить функцию f к этом ящику? И вот здесь появляется функтор (fmap).
			</p>

			<p>
				Решение проблемы побочных эффектов? Возможно речь идёт о любых попутных вычислениях?
				Например, была такая цитата: "Аппликативный функтор работает только с чистыми
				функциями, т. е. в случае аппликативного функтора вы можете совершать над элементами
				контейнера только операции без побочных эффектов (т.е. операции, которые никогда не
				могут вернуть сам контейнер). Монада же позволяет применять к значениям внутри
				контейнера любые операции, в том числе и с побочными эффектами (т.е. возвращающие
				контейнер того же рода).
			</p>

			<p>
				Монады позволяют чистым функциональным языкам осуществлять императивные по сути
				операции, такие, как ввод-вывод и обработку исключений.
			</p>

			<p>
				Простой пример монады - Option. Показать на примере простых математических операций.
			</p>

			<p>
				Показать сравнение, как "протаскивает" значение классическом исключение и как это
				делает монада (Result или кто там).
			</p>

			<p>
				Собрать как можно больше примеров монад: LINQ, генераторы списков, continuations,
				Maybe, Option, await/async/Task.
			</p>
		</section>

		<section>
			<h2>vs ООП</h2>

			<p>
				ФП может быть выгодно с точки зрения <a href="#TODO:">повторного использования</a>.
				Инкапсуляция по сути говорит, что мы можем либо использовать класс целиком, либо не
				можем использовать вообще. Это - очевидный недостаток, лёгкая рекомпозиция
				практически невозможна. Может ООП даёт какие-то преимущества? Да, каждый метод
				неявно получает в качестве аргумента this и может обращаться к состоянию класса. Но
				можно без труда представить себе функции, которые содержат явный параметр этого
				состояния (а точнее, более гранулированный контракт, что повышает реюзинг) и некую
				обобщающую функцию, которая вернет их каррированные версии. Схематически выражаясь:
			</p>

			<code>{`
function objectEmulation() {
	const state = {};

	return {
		create: curry(create, state),
		read: curry(read, state),
		update: curry(update, state)
	}
}
			`}</code>

			<p>
				Потребитель здесь получает специализированный контракт с полностью изолированным
				доступом к внутреннему состоянию.
			</p>

			<p>
				Полиморфизм не составляет труда реализовать. Это, к слову, об упомянутой выше
				рекомпозиции. Можно сконструировать такой объект, что в нём будет заменена буквально
				одна функция. И этот же метод касается вопросов наследования. Можно скомбинировать
				самые разные функции не прибегая к строгим ограничениям наследования.
			</p>
		</section>

		<section>
			<h2>Вопросы</h2>

			<p>
				Предположим, что у нас есть функция вычисления факториала. Она реализована
				рекурсивно. Для ускорения работы факториала мы решили добавить мемоизацию в эту
				функцию. Как это лучше сделать если предположить, что у человека расширяющего
				исходную функцию нет доступа к её коду?
			</p>
		</section>

		<section>
			<h2>InBox</h2>

			<p>
				Монадические аспекты. Например, вычисление значений функции и вывод на экран, это
				функция, которая аспектами значения и с отображения на экране.
			</p>

			<p>Bind описывает flow в некотором смысле.</p>
		</section>
	</Layout>
);

export default Mesh;
